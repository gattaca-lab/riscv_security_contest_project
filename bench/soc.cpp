#include <cstdlib>
#include <string>
#include <cassert>
#include <cstdio>
#include <stdexcept>
#include <iostream>

// verilator headers
#include <verilated.h>
#include <verilated_vcd_c.h>

// rtlsim headers (generated by verilator)
#include <rtlsim/Vsoc.h>
#include <rtlsim/Vsoc_wb_ram__pi1.h>
#include <rtlsim/Vsoc_wb_ram_generic__pi2.h>
#include <rtlsim/Vsoc_soc.h>
#include <rtlsim/Vsoc_wb_cpu_bus.h>
#include <rtlsim/Vsoc_registers.h>
#include <rtlsim/Vsoc_cpu__VBaa1155.h>
#include <rtlsim/Vsoc_wbuart__H0.h>

#include "soc.h"

RV_SOC::RV_SOC(const char* trace)
{
    m_soc = new Vsoc;
    assert(!m_trace);
    if (trace)
    {
        Verilated::traceEverOn(true);
        m_trace = new VerilatedVcdC;
        m_soc->trace(m_trace, 99);
        m_trace->open(trace);
    }
    m_ramSize = sizeof(m_soc->soc->ram0->ram0->mem) / wordSize;
    m_regFileSize = sizeof(m_soc->soc->cpu0->reg_inst->regfile) / wordSize;
    clearRam();
    reset();
}

RV_SOC::~RV_SOC()
{
    if (m_trace)
    {
        m_trace->close();
        m_trace = nullptr;
    }
    assert(m_soc);
    delete m_soc;
}

void RV_SOC::tick(unsigned num)
{
    assert(m_soc);
    for (unsigned i = 0; i < num; i++)
    {
        m_tickCnt++;

        m_soc->clk_i = 0;
        m_soc->eval();

        if (m_trace)
            m_trace->dump(m_tickCnt - 1);

        m_tickCnt++;
        m_soc->clk_i = 1;
        m_soc->eval();

        if (m_trace)
            m_trace->dump(m_tickCnt);

        m_soc->clk_i = 0;
        m_soc->eval();

        if (m_trace)
        {
            m_trace->dump(m_tickCnt + 1);
            m_trace->flush();
        }
    }
}

void RV_SOC::writeWord(unsigned address, uint32_t val)
{
    if (address >= m_ramSize) {
        std::cerr << "writeWord: address " << std::dec << (address * 4) <<
            " (w_idx = 0x" <<  std::hex << address << ") is out of range " <<
            "[RamSize = " << std::dec << m_ramSize * 4 << " bytes]" << std::endl;
        throw std::out_of_range("write: the specified address is out of range");
    }
    m_soc->soc->ram0->ram0->mem[address] = val;
}

uint32_t RV_SOC::readWord(unsigned address)
{
    if (address >= m_ramSize) {
        std::cerr << "readWord: address " << std::dec << (address * 4) <<
            " (w_idx = 0x" << std::hex << address << ") is out of range" <<
            "[RamSize = " << std::dec << m_ramSize * 4 << " bytes]" << std::endl;
        throw std::out_of_range("read: the specified address is out of range");
    }
    return m_soc->soc->ram0->ram0->mem[address];
}

void RV_SOC::reset()
{
    m_soc->rst_i = 1;
    tick();
    m_soc->rst_i = 0;
    tick();
}

uint64_t RV_SOC::getRamSize() const
{
    return m_ramSize;
}
    
uint64_t RV_SOC::getWordSize() const
{
    return wordSize;
}

void RV_SOC::writeReg(unsigned num, uint32_t val)
{
    assert(num < m_regFileSize);
    m_soc->soc->cpu0->reg_inst->regfile[num] = val;
}

uint32_t RV_SOC::readReg(unsigned num)
{
    assert(num < m_regFileSize);
    return m_soc->soc->cpu0->reg_inst->regfile[num];
}

uint32_t RV_SOC::getPC() const
{
    assert(validPc());
    return m_soc->soc->cpu0->pc;
}

uint32_t RV_SOC::getRegFileSize() const
{
    return m_regFileSize;
}

void RV_SOC::clearRam()
{
    for (unsigned i = 0; i < m_ramSize; i++)
    {
        writeWord(i, 0);
    }
}
    
bool RV_SOC::validUartTransaction() const
{
    bool valid = (m_soc->soc->uart0->i_wb_cyc == m_soc->soc->uart0->o_wb_ack) && m_soc->soc->uart0->i_wb_cyc;
    return valid;
}

bool RV_SOC::validUartTxTransaction() const
{
    bool valid = validUartTransaction() && (m_soc->soc->uart0->i_wb_addr == UART_TX_ADDR);
    return valid;
}

bool RV_SOC::validUartRxTransaction() const
{
    bool valid = validUartTransaction() && (m_soc->soc->uart0->i_wb_addr == UART_RX_ADDR);
    return valid;
}

uint8_t RV_SOC::getUartTxData()
{
    assert(validUartTxTransaction());
    uint8_t data = ((m_soc->soc->uart0->i_wb_data >> 24) & 0xFF);
    return data;
}
    
bool RV_SOC::validPc() const
{
    bool valid = (m_soc->soc->cpu0->state == 1) && (m_soc->soc->cpu0->bus_inst->CYC_O) && (m_soc->soc->cpu0->bus_inst->ACK_I);
    return valid;
}
